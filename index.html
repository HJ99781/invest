<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>투자일지</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter 폰트 사용 */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f3f8; /* 아주 연한 파스텔 라벤더 배경 */
            color: #333;
        }
        /* 커스텀 스크롤바 (선택 사항) */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-thumb { background: #b1a0c8; border-radius: 4px; }
        ::-webkit-scrollbar-track { background: #f7f3f8; }

        /* API 로딩 스피너 애니메이션 */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #8e6c8f;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* 테이블 헤더 및 행 스타일 */
        .journal-table th {
            background-color: #c7b3d1; /* 파스텔 보라색 헤더 */
            color: white;
            padding: 12px 16px;
        }

        .journal-table td {
            padding: 12px 16px;
        }

        .journal-table tr:nth-child(even) {
            background-color: #fce8f4; /* 짝수 행 연한 핑크 */
        }

        .journal-table tr:nth-child(odd) {
            background-color: #ffffff; /* 홀수 행 흰색 */
        }

        .journal-table tr:hover {
            background-color: #e5d7ec; /* 호버 시 연한 라벤더 */
        }

        /* 입력 필드 스타일 */
        input[type="text"], input[type="date"], textarea {
            border: 1px solid #d1c4e9;
            padding: 8px;
            border-radius: 8px;
            transition: border-color 0.2s;
        }

        input[type="text"]:focus, input[type="date"]:focus, textarea:focus {
            border-color: #8e6c8f;
            outline: none;
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div id="app" class="max-w-6xl mx-auto bg-white p-6 md:p-10 shadow-xl rounded-2xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-extrabold text-[#8e6c8f] border-b-4 border-[#c7b3d1] pb-2 inline-block">
                📈 투자일지
            </h1>
            <p class="text-md text-gray-500 mt-2">나만의 투자 기록을 매일 정리하고 저장하세요.</p>
        </header>

        <!-- API 키 설정 영역 -->
        <section class="mb-8 p-4 bg-purple-50 rounded-xl shadow-inner">
            <h2 class="text-2xl font-semibold mb-3 text-[#8e6c8f]">🔑 Gemini API 키 설정</h2>
            <div class="flex flex-col md:flex-row gap-3">
                <input type="text" id="api-key-input" placeholder="여기에 Gemini API 키를 입력하세요"
                       class="flex-grow p-2 rounded-lg border border-purple-200 focus:ring-purple-400 focus:border-purple-400 transition">
                <button id="save-api-key"
                        class="bg-[#a591b9] text-white px-6 py-2 rounded-lg font-medium hover:bg-[#8e6c8f] transition shadow-md">
                    저장
                </button>
            </div>
            <p id="api-key-status" class="mt-2 text-sm text-purple-600">API 키가 로컬 스토리지에 저장됩니다.</p>
        </section>

        <!-- 일지 추가 영역 -->
        <section class="mb-10 p-6 bg-pink-50 rounded-xl shadow-lg">
            <h2 class="text-2xl font-semibold mb-4 text-[#8e6c8f]">📝 새로운 기록 추가</h2>

            <!-- 날짜 및 종목 설정 -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <!-- 날짜 선택 기능 추가 -->
                <div>
                    <label for="record-date" class="block text-sm font-medium text-gray-700 mb-1">
                        기록 날짜 선택
                    </label>
                    <input type="date" id="record-date"
                           class="w-full p-2 rounded-lg border border-pink-200 focus:ring-pink-400 focus:border-pink-400 transition">
                </div>
                
                <div>
                    <label for="stock-symbols" class="block text-sm font-medium text-gray-700 mb-1">
                        종목 설정 (쉼표로 구분, 예: 005930.KS, TSLA, AAPL)
                    </label>
                    <input type="text" id="stock-symbols" value="005930.KS, 000660.KS, 035420.KS, 005380.KS, 000270.KS"
                           placeholder="여기에 종목 코드를 입력하세요 (5~15개 권장)"
                           class="w-full p-2 rounded-lg border border-pink-200 focus:ring-pink-400 focus:border-pink-400 transition">
                </div>
            </div>

            <div class="flex flex-col md:flex-row gap-3 mb-4">
                <button id="fetch-data"
                        class="flex-grow flex items-center justify-center bg-[#f0a5b8] text-white px-6 py-3 rounded-lg font-bold hover:bg-[#e47e95] transition shadow-lg disabled:opacity-50"
                        disabled>
                    종가 가져오기
                    <span id="loading-indicator" class="ml-2 hidden">
                        <div class="spinner"></div>
                    </span>
                </button>
            </div>

            <div id="fetched-data-display" class="bg-white p-4 rounded-lg border border-pink-200 hidden">
                <!-- Fetch된 데이터 미리보기 영역 -->
            </div>
            
            <div class="mt-4 text-sm text-gray-500 p-2 bg-gray-50 rounded-lg border border-gray-100">
                ⚠️ **데이터 기준일**은 사용자가 선택한 날짜에 가장 가까운 **가장 최근 마감된 거래일의 정확한 종가**를 기록하기 위해 검색됩니다.
            </div>

            <!-- 메모 입력 및 기록 추가 -->
            <div class="mt-4">
                <label for="memo" class="block text-sm font-medium text-gray-700 mb-1">오늘의 투자 메모</label>
                <textarea id="memo" rows="3" placeholder="오늘의 시장 분석, 투자 결정, 감정 등을 기록하세요."
                          class="w-full p-2 rounded-lg border border-pink-200 focus:ring-pink-400 focus:border-pink-400 transition"></textarea>
            </div>

            <button id="add-entry"
                    class="w-full mt-4 bg-[#8e6c8f] text-white px-6 py-3 rounded-lg font-bold hover:bg-[#a591b9] transition shadow-lg disabled:opacity-50"
                    disabled>
                기록 추가
            </button>

            <p id="message-box" class="mt-3 text-sm text-red-500"></p>
        </section>

        <!-- 기록 목록 및 CSV 다운로드 -->
        <section class="p-6 bg-white rounded-xl shadow-lg border border-gray-100">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-semibold text-[#8e6c8f]">📑 투자 기록 목록</h2>
                <button id="export-csv"
                        class="bg-green-500 text-white px-4 py-2 rounded-lg font-medium hover:bg-green-600 transition shadow-md disabled:opacity-50"
                        disabled>
                    엑셀(CSV) 다운로드
                </button>
            </div>
            <div id="journal-list-container" class="overflow-x-auto">
                <table id="journal-table" class="journal-table w-full text-sm text-left rounded-lg overflow-hidden">
                    <thead>
                        <!-- 헤더는 JavaScript에서 동적으로 생성됨 -->
                    </thead>
                    <tbody>
                        <!-- 데이터는 JavaScript에서 동적으로 생성됨 -->
                    </tbody>
                </table>
                <p id="no-data-message" class="text-center text-gray-500 p-4">아직 기록된 일지가 없습니다.</p>
            </div>
        </section>

    </div>

    <script>
        // 전역 상수 및 변수 설정
        const API_MODEL = "gemini-2.5-flash-preview-05-20";
        const API_URL_BASE = "https://generativelanguage.googleapis.com/v1beta/models/";
        const JOURNAL_STORAGE_KEY = 'investmentJournal';
        const API_KEY_STORAGE_KEY = 'geminiApiKey';
        const STOCK_SYMBOLS_STORAGE_KEY = 'investmentStockSymbols'; 
        const MAX_RETRIES = 8; // API 서버 과부하 오류(503)에 더 잘 대응하기 위해 재시도 횟수를 늘림

        // UI 요소
        const apiKeyInput = document.getElementById('api-key-input');
        const saveApiKeyBtn = document.getElementById('save-api-key');
        const apiKeyStatus = document.getElementById('api-key-status');
        const recordDateInput = document.getElementById('record-date');
        const stockSymbolsInput = document.getElementById('stock-symbols');
        const fetchDataBtn = document.getElementById('fetch-data');
        const loadingIndicator = document.getElementById('loading-indicator');
        const fetchedDataDisplay = document.getElementById('fetched-data-display');
        const memoInput = document.getElementById('memo');
        const addEntryBtn = document.getElementById('add-entry');
        const exportCsvBtn = document.getElementById('export-csv');
        const journalTable = document.getElementById('journal-table');
        const messageBox = document.getElementById('message-box');
        const noDataMessage = document.getElementById('no-data-message');

        let journalData = [];
        let currentFetchedData = null; // API에서 가져온 임시 데이터 저장

        // --- 헬퍼 함수 ---

        // 현재 시각 가져오기 (클라이언트 시간)
        function getCurrentDateTime() {
            const now = new Date();
            const dateOptions = { year: 'numeric', month: '2-digit', day: '2-digit' };
            const timeOptions = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };
            const date = now.toLocaleDateString('ko-KR', dateOptions);
            const time = now.toLocaleTimeString('ko-KR', timeOptions);
            return `${date} ${time}`;
        }

        // 로컬 스토리지에 종목 코드 저장
        function saveStockSymbols() {
            const symbols = stockSymbolsInput.value.trim();
            if (symbols) {
                localStorage.setItem(STOCK_SYMBOLS_STORAGE_KEY, symbols);
            } else {
                localStorage.removeItem(STOCK_SYMBOLS_STORAGE_KEY);
            }
        }

        // 로컬 스토리지에서 종목 코드 로드
        function loadStockSymbols() {
            const storedSymbols = localStorage.getItem(STOCK_SYMBOLS_STORAGE_KEY);
            if (storedSymbols) {
                stockSymbolsInput.value = storedSymbols;
            }
        }

        // 로컬 스토리지에 API 키 저장
        function saveApiKey() {
            const apiKey = apiKeyInput.value.trim();
            if (apiKey) {
                localStorage.setItem(API_KEY_STORAGE_KEY, apiKey);
                apiKeyStatus.textContent = "✅ API 키가 저장되었습니다.";
                apiKeyStatus.classList.replace('text-red-500', 'text-purple-600');
                fetchDataBtn.disabled = false;
            } else {
                localStorage.removeItem(API_KEY_STORAGE_KEY);
                apiKeyStatus.textContent = "❌ API 키를 입력해주세요.";
                apiKeyStatus.classList.replace('text-purple-600', 'text-red-500');
                fetchDataBtn.disabled = true;
            }
            saveStockSymbols(); 
        }

        // 로컬 스토리지에서 API 키 로드
        function loadApiKey() {
            const apiKey = localStorage.getItem(API_KEY_STORAGE_KEY);
            if (apiKey) {
                apiKeyInput.value = apiKey;
                apiKeyStatus.textContent = "✅ 저장된 API 키가 로드되었습니다.";
                apiKeyStatus.classList.replace('text-red-500', 'text-purple-600');
                fetchDataBtn.disabled = false;
            } else {
                apiKeyStatus.textContent = "⚠️ API 키를 입력 후 저장하여 기능을 활성화하세요.";
                apiKeyStatus.classList.replace('text-purple-600', 'text-red-500');
                fetchDataBtn.disabled = true;
            }
            
            // 날짜 입력 필드의 기본값을 오늘 날짜로 설정
            const today = new Date().toISOString().slice(0, 10);
            recordDateInput.value = today;
        }

        // 로컬 스토리지에서 일지 데이터 로드
        function loadJournalData() {
            const storedData = localStorage.getItem(JOURNAL_STORAGE_KEY);
            if (storedData) {
                try {
                    journalData = JSON.parse(storedData);
                    // 데이터 로드 시 날짜 오름차순으로 정렬 (가장 오래된 기록이 위로)
                    journalData.sort((a, b) => new Date(a.date) - new Date(b.date));
                } catch (e) {
                    console.error("Error parsing journal data from localStorage:", e);
                    journalData = [];
                }
            } else {
                journalData = [];
            }
            renderJournalTable();
        }

        // 로컬 스토리지에 일지 데이터 저장
        function saveJournalData() {
            localStorage.setItem(JOURNAL_STORAGE_KEY, JSON.stringify(journalData));
            renderJournalTable();
        }

        // 메시지 박스 표시
        function showMessage(text, isError = false) {
            messageBox.textContent = text;
            messageBox.classList.remove('text-red-500', 'text-green-500');
            messageBox.classList.add(isError ? 'text-red-500' : 'text-green-500');
        }

        // 지수 및 주식 종가 데이터 가져오기 (Gemini API)
        async function fetchStockData() {
            const apiKey = apiKeyInput.value.trim();
            const symbols = stockSymbolsInput.value.trim();
            const selectedDate = recordDateInput.value;

            if (!apiKey || !symbols || !selectedDate) {
                showMessage("API 키, 종목 코드, 그리고 기록 날짜를 모두 입력/선택해주세요.", true);
                return;
            }

            saveStockSymbols();

            // UI 상태 업데이트
            fetchDataBtn.disabled = true;
            addEntryBtn.disabled = true;
            loadingIndicator.classList.remove('hidden');
            showMessage("데이터를 가져오는 중입니다...", false);
            fetchedDataDisplay.classList.add('hidden');

            const API_URL = `${API_URL_BASE}${API_MODEL}:generateContent?key=${apiKey}`;
            
            const systemPrompt = `
                당신은 전문적인 금융 데이터 분석가입니다.
                사용자의 요청에 따라 **반드시 다음 JSON 스키마를 사용하여 응답하십시오.**
                응답은 **JSON 문자열 그 자체**여야 하며, 어떠한 설명, 서론, 결론, 마크다운 코드 블록(\`\`\`json)도 포함하지 마십시오.
                모든 가격은 숫자(정수 또는 소수점 두 자리까지) 형식이어야 합니다.
                
                JSON 데이터 구조 예시:
                {
                    "date": "2025-05-15",
                    "KOSPI": 2700.50,
                    "KOSDAQ": 850.25,
                    "stocks": [
                        {"symbol": "005930.KS", "name": "삼성전자", "price": 80000},
                        {"symbol": "AAPL", "name": "Apple Inc.", "price": 195.50},
                        ...
                    ]
                }
            `;

            const userQuery = `
                **[최대 강도]** 웹 검색을 사용하여 다음 조건을 충족하는 종가 데이터를 찾으십시오:
                1. 데이터 기준일은 ${selectedDate}에 가장 가깝고, 이 날짜를 초과하지 않는 가장 최근 거래일의 종가 데이터여야 합니다. (선택한 날짜 이전/당일 중 가장 최근 마감일)
                2. 데이터의 기준 시점은 한국 시장 마감 시간인 15:30 KST를 충족해야 합니다.
                3. **각 종목에 대해 종목명(회사 이름)을 반드시 포함하십시오.**
                검색 대상 지수 및 주식 종목 코드 (쉼표로 구분): KOSPI, KOSDAQ, ${symbols}
            `;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                tools: [{ "google_search": {} }],
                
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                }
            };

            for (let i = 0; i < MAX_RETRIES; i++) {
                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorBody = await response.text();
                        throw new Error(`API 요청 실패: ${response.status} ${response.statusText} (Response: ${errorBody.substring(0, 100)}...)`);
                    }

                    const result = await response.json();
                    
                    const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (!jsonText) {
                        throw new Error("API 응답에서 유효한 JSON 텍스트를 찾을 수 없거나 응답이 비어 있습니다.");
                    }

                    let fetchedJson;
                    try {
                        fetchedJson = JSON.parse(jsonText);
                    } catch (e) {
                        console.error("JSON Parsing Error:", e);
                        throw new Error("모델이 유효한 JSON 형식을 반환하지 않았습니다. 모델이 설명 텍스트를 추가했을 수 있습니다: " + jsonText.substring(0, 50));
                    }


                    currentFetchedData = fetchedJson;
                    
                    const clientDateTime = getCurrentDateTime();

                    // 데이터 미리보기 렌더링
                    renderFetchedData(fetchedJson, clientDateTime);
                    showMessage(`✅ ${fetchedJson.date} 데이터 가져오기 성공! (가장 최근 마감일 기준)`, false);
                    addEntryBtn.disabled = false;
                    return; // 성공 시 루프 종료

                } catch (error) {
                    console.error(`Attempt ${i + 1} failed:`, error.message);
                    if (i === MAX_RETRIES - 1) {
                        showMessage(`❌ 데이터 가져오기 실패: ${error.message}. API 키를 확인하거나, 날짜를 다시 선택하거나, 잠시 후 다시 시도해주세요.`, true);
                    }
                    // Exponential backoff
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                }
            }

            // 모든 시도가 실패했을 때 UI 복구
            fetchDataBtn.disabled = false;
            loadingIndicator.classList.add('hidden');
            currentFetchedData = null;
        }

        // 가져온 데이터 미리보기 표시
        function renderFetchedData(data, clientTime) {
            const stocksHtml = data.stocks.map(stock => 
                `<span class="inline-block bg-purple-100 text-purple-800 text-xs font-semibold px-2.5 py-0.5 rounded-full mr-2 mb-1"
                      title="${stock.symbol}">
                    ${stock.name} (${stock.symbol}): ${formatPrice(stock.price)}
                </span>`
            ).join('');

            fetchedDataDisplay.innerHTML = `
                <p class="text-sm text-gray-500 mb-1">📅 조회 시각: ${clientTime}</p>
                <p class="font-bold text-lg text-[#8e6c8f] mb-2">📊 데이터 기준일: ${data.date} (가장 최근 마감일)</p>
                <div class="grid grid-cols-2 gap-2 mb-3 text-sm">
                    <p><strong>KOSPI:</strong> ${formatPrice(data.KOSPI)}</p>
                    <p><strong>KOSDAQ:</strong> ${formatPrice(data.KOSDAQ)}</p>
                </div>
                <p class="font-semibold text-gray-700 mb-1">개별 종목 종가:</p>
                <div>${stocksHtml}</div>
            `;
            fetchedDataDisplay.classList.remove('hidden');
        }

        // 가격 포맷팅 헬퍼
        function formatPrice(price) {
            if (typeof price === 'number') {
                return price.toLocaleString('ko-KR', { minimumFractionDigits: 0, maximumFractionDigits: 2 });
            }
            return price;
        }

        // 새로운 기록 추가
        function addJournalEntry() {
            if (!currentFetchedData) {
                showMessage("먼저 '종가 가져오기' 버튼을 눌러 데이터를 불러와주세요.", true);
                return;
            }

            const memo = memoInput.value.trim() || '메모 없음';
            const newEntry = {
                id: Date.now(),
                ...currentFetchedData,
                memo: memo
            };

            // 이미 같은 날짜의 데이터가 있는지 확인
            const isDuplicate = journalData.some(entry => entry.date === newEntry.date);
            if (isDuplicate) {
                showMessage(`❌ ${newEntry.date} 날짜의 기록은 이미 존재합니다.`, true);
                return;
            }

            // [수정] 최신 데이터를 맨 뒤에 추가 (오래된 순서대로 표시)
            journalData.push(newEntry); 
            // 배열에 새로운 데이터가 추가되었으므로 다시 정렬
            journalData.sort((a, b) => new Date(a.date) - new Date(b.date));

            saveJournalData();
            
            // UI 초기화
            memoInput.value = '';
            currentFetchedData = null;
            fetchedDataDisplay.classList.add('hidden');
            addEntryBtn.disabled = true;
            showMessage(`✅ ${newEntry.date} 기록이 성공적으로 추가되었습니다.`, false);
        }
        
        // 데이터 테이블 렌더링
        function renderJournalTable() {
            const tableHead = journalTable.querySelector('thead');
            const tableBody = journalTable.querySelector('tbody');

            // 데이터가 없으면 메시지 표시
            if (journalData.length === 0) {
                tableHead.innerHTML = '';
                tableBody.innerHTML = '';
                noDataMessage.classList.remove('hidden');
                exportCsvBtn.disabled = true;
                return;
            }

            noDataMessage.classList.add('hidden');
            exportCsvBtn.disabled = false;

            // 1. 헤더 생성 (첫 번째 항목 기준으로)
            const firstEntry = journalData[0];
            let headers = ['날짜', 'KOSPI', 'KOSDAQ'];
            
            // 동적 헤더 및 심볼 키를 저장할 배열
            const dynamicDisplayHeaders = []; 
            const dynamicSymbolKeys = []; 

            // 헤더에 종목 이름과 코드를 함께 표시
            firstEntry.stocks.forEach(stock => {
                const headerText = `${stock.name} (${stock.symbol})`;
                dynamicDisplayHeaders.push(headerText);
                dynamicSymbolKeys.push(stock.symbol); // 데이터 룩업을 위한 키 저장
            });
            
            headers.push(...dynamicDisplayHeaders);
            headers.push('메모 (클릭하여 수정)', '삭제'); // 메모 헤더 업데이트

            tableHead.innerHTML = `
                <tr>
                    ${headers.map(h => `<th scope="col" class="py-3 px-6 text-xs font-semibold uppercase tracking-wider">${h}</th>`).join('')}
                </tr>
            `;

            // 2. 바디 생성
            tableBody.innerHTML = journalData.map(entry => {
                // HTML 엔티티 이스케이프 함수
                const escapeHtml = (unsafe) => {
                    if (!unsafe) return '';
                    return unsafe.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                };

                let row = [
                    `<td class="font-medium text-gray-900 whitespace-nowrap">${entry.date}</td>`,
                    `<td>${formatPrice(entry.KOSPI)}</td>`,
                    `<td>${formatPrice(entry.KOSDAQ)}</td>`
                ];

                // 현재 엔트리의 종목 가격을 심볼로 찾기 쉽게 Map으로 변환
                const stockPricesMap = entry.stocks.reduce((map, stock) => {
                    map[stock.symbol] = stock.price;
                    return map;
                }, {});

                // dynamicSymbolKeys 순서대로 가격 데이터를 삽입
                dynamicSymbolKeys.forEach(symbol => {
                    // Symbol 키를 사용하여 가격을 조회
                    const price = stockPricesMap[symbol] !== undefined ? formatPrice(stockPricesMap[symbol]) : '-';
                    row.push(`<td>${price}</td>`);
                });

                // [수정] 메모를 클릭하여 수정할 수 있는 Span 태그로 렌더링
                row.push(`
                    <td data-id="${entry.id}">
                        <span id="memo-display-${entry.id}" 
                              onclick="startEditingMemo(${entry.id})" 
                              class="block cursor-pointer hover:bg-yellow-50 p-1 rounded-md max-w-xs break-words text-gray-700"
                              title="클릭하여 수정">
                            ${escapeHtml(entry.memo)}
                        </span>
                    </td>
                `);

                row.push(`<td>
                    <button onclick="deleteEntry(${entry.id})" 
                            class="text-red-500 hover:text-red-700 transition focus:outline-none">
                        ❌
                    </button>
                </td>`);

                return `<tr>${row.join('')}</tr>`;
            }).join('');
        }

        // 기록 삭제
        window.deleteEntry = function(id) {
            journalData = journalData.filter(entry => entry.id !== id);
            saveJournalData();
            showMessage('기록이 삭제되었습니다.', false);
        }

        // [추가] 메모 수정 시작
        window.startEditingMemo = function(id) {
            const displayElement = document.getElementById(`memo-display-${id}`);
            if (!displayElement) return;

            const currentMemo = displayElement.textContent.trim();
            const parentCell = displayElement.parentElement;
            
            // 1. 텍스트 영역 생성
            const textarea = document.createElement('textarea');
            textarea.id = `memo-input-${id}`;
            textarea.className = 'w-full p-1 border border-purple-400 rounded-md text-sm resize-none focus:ring-purple-500 focus:border-purple-500 shadow-inner';
            textarea.value = currentMemo;
            textarea.rows = Math.max(3, currentMemo.split('\n').length); // 메모 길이에 따라 높이 조정
            textarea.setAttribute('data-original-memo', currentMemo); // Esc 키 복원을 위해 원본 저장

            // 2. 수정 완료 (Blur 이벤트: 포커스를 잃으면 저장)
            textarea.addEventListener('blur', () => {
                saveMemo(id, textarea);
            });
            
            // 3. Enter 키 입력 시 저장 (Shift+Enter는 줄 바꿈)
            textarea.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    textarea.blur(); // blur 이벤트 발생시켜 저장 및 뷰 전환
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    // Esc 누르면 원본으로 복원
                    const originalMemo = textarea.getAttribute('data-original-memo');
                    const entryIndex = journalData.findIndex(entry => entry.id === id);
                    if (entryIndex !== -1) {
                        journalData[entryIndex].memo = originalMemo; // 임시로 원본 메모로 복원
                    }
                    textarea.blur(); // blur를 통해 renderJournalTable이 호출되도록 함
                }
            });

            // 4. 교체 및 포커스
            parentCell.innerHTML = '';
            parentCell.appendChild(textarea);
            textarea.focus();
        }
        
        // [추가] 메모 저장 및 뷰 복원
        function saveMemo(id, textareaElement) {
            const newMemo = textareaElement.value.trim() || '메모 없음';
            const entryIndex = journalData.findIndex(entry => entry.id === id);

            if (entryIndex !== -1) {
                // 내용이 변경된 경우에만 저장
                if (journalData[entryIndex].memo !== newMemo) {
                    journalData[entryIndex].memo = newMemo;
                    saveJournalData(); // 로컬 스토리지에 저장 및 테이블 리렌더링
                    showMessage('✅ 메모가 수정되었습니다.', false);
                    return;
                }
            }

            // 변경 사항이 없거나 오류가 발생했을 경우:
            // renderJournalTable()을 호출하여 메모를 다시 <span> 태그로 되돌립니다.
            renderJournalTable();
            if (entryIndex === -1) {
                showMessage('❌ 메모를 저장할 기록을 찾을 수 없습니다.', true);
            }
        }

        // CSV 파일로 다운로드
        function exportToCSV() {
            if (journalData.length === 0) {
                showMessage("다운로드할 데이터가 없습니다.", true);
                return;
            }

            // 1. 헤더 (CSV는 분석 편의를 위해 종목 이름과 코드를 함께 헤더로 유지합니다)
            const firstEntry = journalData[0];
            let headers = ['날짜', 'KOSPI', 'KOSDAQ'];
            const symbolKeys = [];

            // 종목 이름과 코드를 함께 헤더로 사용
            firstEntry.stocks.forEach(stock => {
                headers.push(`${stock.name} (${stock.symbol})`);
                symbolKeys.push(stock.symbol);
            });
            headers.push('메모');

            let csvContent = headers.join(',') + '\n';

            // 2. 데이터 행
            journalData.forEach(entry => {
                const stockPrices = {};
                entry.stocks.forEach(stock => { stockPrices[stock.symbol] = stock.price; });

                let rowData = [
                    entry.date,
                    entry.KOSPI,
                    entry.KOSDAQ
                ];

                // SymbolKeys 순서에 맞춰 가격 데이터를 삽입
                symbolKeys.forEach(symbol => { 
                    const price = stockPrices[symbol] !== undefined ? stockPrices[symbol] : '';
                    rowData.push(price);
                });

                // 메모 필드는 쉼표 문제 방지를 위해 따옴표로 감쌈
                // 줄 바꿈은 공백으로 대체하고, 따옴표는 이중 따옴표로 이스케이프 처리
                rowData.push(`"${entry.memo.replace(/"/g, '""').replace(/\n/g, ' ')}"`);
                csvContent += rowData.join(',') + '\n';
            });

            // 3. 파일 다운로드
            const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8;' }); // BOM 추가하여 한글 깨짐 방지
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `투자일지_기록_${new Date().toISOString().slice(0, 10)}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showMessage('✅ 기록을 CSV 파일로 다운로드했습니다.', false);
        }

        // --- 이벤트 리스너 설정 ---

        // API 키 저장 버튼 클릭
        saveApiKeyBtn.addEventListener('click', saveApiKey);

        // 종가 가져오기 버튼 클릭
        fetchDataBtn.addEventListener('click', fetchStockData);

        // 기록 추가 버튼 클릭
        addEntryBtn.addEventListener('click', addJournalEntry);

        // CSV 다운로드 버튼 클릭
        exportCsvBtn.addEventListener('click', exportToCSV);
        
        // 종목 설정 입력란의 내용이 변경되거나 포커스를 잃으면 즉시 저장
        stockSymbolsInput.addEventListener('change', saveStockSymbols);

        // 초기 로드
        window.onload = () => {
            loadApiKey();
            loadStockSymbols();
            loadJournalData();
        };

    </script>
</body>
</html>
